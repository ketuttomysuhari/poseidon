<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Poseidon WebGIS</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css">
<script>window.CESIUM_BASE_URL="https://unpkg.com/cesium/Build/Cesium/";</script>
<script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>
<script src="https://cdn.jsdelivr.net/npm/proj4@2.9.1/dist/proj4.js"></script>
<style>
  :root{ --sidebar-w: 360px; }
  html,body{height:100%;margin:0;background:#0b0f19;color:#eaeef6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #layout{display:grid;grid-template-columns:var(--sidebar-w) 1fr;grid-template-rows:100%;height:100%}
  /* Sidebar */
  #sidebar{background:#0d1324;border-right:1px solid #1f2a44;display:flex;flex-direction:column;min-width:300px;max-width:560px}
  #brand{display:flex;align-items:center;gap:12px;padding:14px;border-bottom:1px solid #1f2a44}
  #brand img.poseidon-logo{height:72px;width:auto;border-radius:12px;object-fit:contain}
  #brand h1{font-size:16px;margin:0;color:#c7d2fe;letter-spacing:.3px}
  #controls{padding:12px;overflow:auto;display:flex;flex-direction:column;gap:12px}
  .card{border:1px solid #1f2a44;border-radius:12px;background:#0f1526;padding:12px}
  .card h3{margin:0 0 10px 0;font-size:12px;text-transform:uppercase;letter-spacing:.08em;color:#9fb3ff}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  label{font-size:12px;opacity:.9}
  input,select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #2a385e;background:#0b1120;color:#eaeef6}
  input[type=file]{color:#9fb3ff}
  .btn{background:linear-gradient(180deg,#3b82f6,#2563eb);border:none;color:#fff;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  .btn.secondary{background:#223055}
  .stack{display:flex;flex-wrap:wrap;gap:8px}
  .switch{display:flex;gap:8px;align-items:center}
  .muted{font-size:12px;opacity:.8}
  .status{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #2a385e;background:#0b1120;font-size:12px;color:#9fb3ff}

  /* Map panel */
  #map{position:relative}
  #cesiumContainer{position:absolute;inset:0}

  /* Legend: mengambang di kanan bawah map */
  #legend{position:absolute;right:12px;bottom:12px;z-index:15;background:rgba(18,24,38,.92);border:1px solid #1f2a44;border-radius:10px;padding:10px;min-width:120px}
  #legend h5{margin:0 0 6px 0;font-size:12px;color:#c7d2fe}
  #legend canvas{display:block;border:1px solid #1f2a44;border-radius:8px;background:#0b1120}
  #legend .muted{margin-top:6px}

  /* Popup */
  #popup{position:absolute;z-index:20;min-width:220px;max-width:320px;background:rgba(14,18,30,.98);border:1px solid #223055;border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,.35);padding:10px;display:none;pointer-events:none}
  #popup h4{margin:0 0 6px 0;font-size:13px;color:#c7d2fe}
  #popup .rowp{font-size:12px;display:flex;justify-content:space-between;gap:8px}
  /* Sembunyikan watermark Cesium */
  .cesium-widget-credits{display:none !important}

  /* Panel hasil profil sederhana */
  #profileBox{border:1px solid #1f2a44;border-radius:10px;background:#0f1526;padding:10px}
  #profileCanvas{width:100%;height:160px;border:1px solid #1f2a44;border-radius:8px;background:#0b1120}
  #profileStats{font-size:12px;margin-top:6px;opacity:.9}
</style>
</head>
<body>
<div id="layout">
  <!-- ========== SIDEBAR ========== -->
  <aside id="sidebar">
    <div id="brand">
      <img src="poseidon.png" class="poseidon-logo" alt="Poseidon" />
    </div>

    <div id="controls">
      <!-- DATA -->
      <div class="card">
        <h3>Data</h3>
        <div class="row">
          <div>
            <label>File XYZ</label>
            <input id="fileInput" type="file" accept=".xyz,.txt,.csv" />
          </div>
          <div>
            <label>Delimiter</label>
            <select id="delimiter">
              <option value="auto" selected>Auto (spasi/komma)</option>
              <option value="comma">Comma</option>
              <option value="space">Whitespace</option>
            </select>
          </div>
        </div>
        <div class="stack" style="margin-top:8px">
          <button class="btn" id="btnLoad">Tampilkan Titik</button>
          <button class="btn" id="btnBuildDTM">Buat DTM</button>
          <button class="btn secondary" id="btnRecolor">Recolor</button>
          <button class="btn secondary" id="btnClear">Bersihkan</button>
        </div>
        <div style="margin-top:8px"><span class="status" id="status">Auto-load <b>DTM.xyz</b> jika ada…</span></div>
        <div class="muted" style="margin-top:8px">Koordinat diasumsikan <b>UTM 49S (EPSG:32749)</b> → otomatis ke WGS84.</div>
      </div>

      <!-- TITIK -->
      <div class="card">
        <h3>Titik</h3>
        <div class="row">
          <div>
            <label>Point Size</label>
            <input id="pointSize" type="number" value="6" min="1" step="1" />
          </div>
          <div>
            <label>Z Offset (m)</label>
            <input id="zOffset" type="number" value="0" step="0.1" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="switch">
            <input id="pointsOnTop" type="checkbox" checked />
            <span class="muted">Always on Top</span>
          </div>
          <div class="switch">
            <input id="colorizePoints" type="checkbox" checked />
            <span class="muted">Warna = Bin DTM</span>
          </div>
        </div>
      </div>

      <!-- DTM -->
      <div class="card">
        <h3>DTM</h3>
        <div class="row">
          <div>
            <label>Grid Step (deg)</label>
            <input id="gridStepDeg" type="number" value="0.0005" step="0.0001" />
          </div>
          <div>
            <label>Z Exaggeration</label>
            <input id="zExag" type="number" value="1.0" step="0.1" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label>Bins</label>
            <input id="bins" type="number" value="15" min="4" max="64" step="1" />
          </div>
          <div>
            <label>Palette</label>
            <select id="palette">
              <option value="bgyor" selected>Biru→Hijau→Kuning→Oranye→Merah</option>
              <option value="jet">Jet</option>
              <option value="viridis">Viridis</option>
            </select>
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="switch">
            <input id="autoZRange" type="checkbox" checked />
            <span class="muted">Range Z Auto</span>
          </div>
          <div>
            <label>Z Min, Z Max (manual)</label>
            <input id="zMinMax" type="text" placeholder="mis. 2.64, 11.19" />
          </div>
        </div>
        <div class="switch" style="margin-top:8px">
          <input id="underground" type="checkbox" />
          <span class="muted">Underground (terrain transparan)</span>
        </div>
      </div>

      <!-- ANALISIS -->
      <div class="card">
        <h3>Analisis</h3>
        <div class="row">
          <div>
            <label>Mode Gambar</label>
            <select id="drawMode">
              <option value="none" selected>— pilih —</option>
              <option value="line">Profil (garis)</option>
              <option value="polygon">Poligon (luas/volume)</option>
            </select>
          </div>
          <div>
            <label>Sampling Profil</label>
            <input id="profileSamples" type="number" value="200" min="50" step="10" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label>Elev. Referensi (m)</label>
            <input id="refElevation" type="number" value="0" step="0.1" />
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="btnResetDraw" class="btn secondary" style="width:100%">Reset Gambar</button>
          </div>
        </div>

        <div id="profileBox" style="margin-top:10px; display:none">
          <canvas id="profileCanvas" width="600" height="160"></canvas>
          <div id="profileStats"></div>
        </div>

        <div id="polyStats" class="muted" style="margin-top:8px; display:none"></div>
      </div>
    </div>
  </aside>

  <!-- ========== MAP PANEL ========== -->
  <main id="map">
    <div id="cesiumContainer"></div>

    <!-- Legend mengambang (kanan bawah) -->
    <div id="legend">
      <h5>Elevation (m)</h5>
      <canvas id="legendCanvas" width="56" height="260"></canvas>
      <div id="legendTicks" class="muted"></div>
    </div>

    <div id="popup"></div>
  </main>
</div>

<script>
(async function(){
  Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJhNGQwNTBlZS1iOGVlLTQxZDgtODdiMC03YWQ1ZGUzYWFjZTQiLCJpZCI6MjUyMDkzLCJpYXQiOjE3NjA0MTgyNjB9.N9LrYm3UyvJs5Qgkm2P2DDbIReiWGp1MGOqz-fwfHTc";

  const viewer = new Cesium.Viewer('cesiumContainer', {
    terrainProvider: await Cesium.createWorldTerrainAsync(),
    baseLayerPicker: true, geocoder: false, homeButton: true,
    animation: false, timeline: false, sceneModePicker: true, navigationHelpButton: false
  });
  viewer.scene.globe.depthTestAgainstTerrain = false;
  try { viewer.cesiumWidget.creditContainer.style.display = 'none'; } catch(e){}

  // OSM Buildings
  try { viewer.scene.primitives.add(await Cesium.createOsmBuildingsAsync()); } catch(e){ console.warn(e); }

  // ====== CRS
  const UTM49S = "+proj=utm +zone=49 +south +datum=WGS84 +units=m +no_defs";
  const WGS84  = "+proj=longlat +datum=WGS84 +no_defs";

  // ====== Layers & state
  const pointLayer = new Cesium.PointPrimitiveCollection();
  viewer.scene.primitives.add(pointLayer);
  let dtmPrimitive = null;

  let lonlatz = [];   // {lon,lat,z} offset-applied
  let rawUTM  = [];   // {E,N,Z}
  let zStats  = null; // {min,max}
  const drawLayer = viewer.scene.primitives.add(new Cesium.PrimitiveCollection());
  let activePolyline = null, activePolygon = null, drawPositions = [];

  // ====== UI refs
  const $ = id => document.getElementById(id);
  const statusEl=$("status"), fileInput=$("fileInput"), btnLoad=$("btnLoad"),
        btnBuildDTM=$("btnBuildDTM"), btnRecolor=$("btnRecolor"), btnClear=$("btnClear");
  const delimiterSel=$("delimiter"), zExagInp=$("zExag"), gridStepInp=$("gridStepDeg");
  const pointSizeInp=$("pointSize"), zOffsetInp=$("zOffset"),
        undergroundChk=$("underground"), pointsOnTop=$("pointsOnTop"),
        binsInp=$("bins"), autoZRange=$("autoZRange"), zMinMax=$("zMinMax"),
        paletteSel=$("palette"), colorizePoints=$("colorizePoints");
  const legendCanvas=$("legendCanvas"), legendTicks=$("legendTicks");
  const popupEl=$("popup");

  const drawModeSel=$("drawMode"), profileSamplesInp=$("profileSamples"),
        refElevInp=$("refElevation"), btnResetDraw=$("btnResetDraw"),
        profileBox=$("profileBox"), profileCanvas=$("profileCanvas"),
        profileStats=$("profileStats"), polyStats=$("polyStats");

  const setStatus = html => statusEl.innerHTML = html;

  // ===== Helpers (parsing, palettes, legend) =====
  function parseLine(line, mode){
    let parts;
    if (mode==="comma") parts=line.split(",");
    else if (mode==="space") parts=line.trim().split(/\s+/);
    else parts = line.includes(",") ? line.split(",") : line.trim().split(/\s+/);
    if (parts.length < 3) return null;
    return parts.slice(0,3).map(v=>parseFloat(v));
  }

  function parseUTM49S(text){
    const lines=text.split(/\r?\n/);
    const utm=[], wgs=[];
    const zOffset=Number(zOffsetInp.value)||0;
    let zMin=+Infinity, zMax=-Infinity;

    for (const raw of lines){
      const line=raw.trim(); if (!line) continue;
      if (!/[-+0-9.]/.test(line[0])) continue;
      const v=parseLine(line, delimiterSel.value); if (!v) continue;
      let [E,N,Z]=v; if (isNaN(E)||isNaN(N)||isNaN(Z)) continue;
      const [lon,lat]=proj4(UTM49S, WGS84, [E,N]);
      const zAdj=Z + zOffset;
      zMin=Math.min(zMin,zAdj); zMax=Math.max(zMax,zAdj);
      utm.push({E,N,Z}); wgs.push({lon,lat,z:zAdj});
    }
    return {utm,wgs,zMin,zMax};
  }

  function flyToBounds(data){
    if (!data.length) return;
    let minLon=+Infinity,minLat=+Infinity,maxLon=-Infinity,maxLat=-Infinity;
    for (const p of data){
      minLon=Math.min(minLon,p.lon); minLat=Math.min(minLat,p.lat);
      maxLon=Math.max(maxLon,p.lon); maxLat=Math.max(maxLat,p.lat);
    }
    const rect=Cesium.Rectangle.fromDegrees(minLon,minLat,maxLon,maxLat);
    viewer.camera.flyTo({destination:rect,duration:1.1});
  }

  function hex(h){const v=h.replace('#','');return [parseInt(v.slice(0,2),16),parseInt(v.slice(2,4),16),parseInt(v.slice(4,6),16)];}
  function lerp(a,b,t){return a+(b-a)*t;}
  function lerpC(c1,c2,t){return [Math.round(lerp(c1[0],c2[0],t)),Math.round(lerp(c1[1],c2[1],t)),Math.round(lerp(c1[2],c2[2],t))];}
  function makePalette(name, n){
    const arr=[];
    if (name==="viridis"){
      const stops=[[68,1,84],[59,82,139],[33,145,140],[94,201,98],[253,231,37]];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    } else if (name==="jet"){
      const stops=[[0,0,131],[0,60,170],[5,255,255],[255,255,0],[250,0,0],[128,0,0]];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    } else {
      const stops=[[0,0,255],[0,255,0],[255,255,0],[255,153,0],[255,0,0]];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    }
    return arr;
  }

  function computeZRange(){
    if (autoZRange.checked || !zMinMax.value.trim()){
      return [zStats?.min ?? Math.min(...lonlatz.map(p=>p.z)),
              zStats?.max ?? Math.max(...lonlatz.map(p=>p.z))];
    }
    const parts=zMinMax.value.split(',').map(s=>parseFloat(s.trim()));
    if (parts.length>=2 && parts.every(v=>!isNaN(v))) return [parts[0],parts[1]];
    return [Math.min(...lonlatz.map(p=>p.z)), Math.max(...lonlatz.map(p=>p.z))];
  }

  function drawLegend(colors, zmin, zmax, ticks=6){
    const canvas = legendCanvas;
    const ctx=canvas.getContext('2d');
    const w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    const n=colors.length;
    for(let i=0;i<n;i++){
      const c=colors[n-1-i];
      ctx.fillStyle=`rgb(${c[0]},${c[1]},${c[2]})`;
      const y=i*(h/n);
      ctx.fillRect(24,y,w-24,h/n+1);
    }
    ctx.fillStyle="#eaeef6"; ctx.font="11px system-ui";
    ctx.textAlign="right"; ctx.textBaseline="middle";
    for(let i=0;i<ticks;i++){
      const t=i/(ticks-1);
      const z=lerp(zmin,zmax,1-t);
      const y=lerp(0,h,t);
      ctx.fillRect(20,y,4,1);
      ctx.fillText(z.toFixed(1)+" m",18,y);
    }
    legendTicks.textContent = `Bins: ${n}  |  Range: ${zmin.toFixed(2)} – ${zmax.toFixed(2)} m`;
  }

  function colorIndexForZ(z, zmin, zmax, bins){
    if (zmax===zmin) return 0;
    let t=(z - zmin)/(zmax - zmin);
    t=Math.max(0,Math.min(1,t));
    return Math.min(bins-1, Math.floor(t*bins));
  }

  // ===== DTM build + metadata (tambahkan grid z untuk analisis) =====
  let dtmMeta = null; // {minLon,minLat,stepDeg,nx,ny,zGrid[]}

  function buildDTMQuantized(data, stepDeg, zExag, bins, palette, zmin, zmax){
    stepDeg = Math.max(1e-6, Number(stepDeg)||0.0005);
    zExag   = Number(zExag)||1.0;
    bins    = Math.max(4, Math.min(256, Math.floor(bins)||15));
    const colors = makePalette(palette, bins);

    // bounds
    let minLon=+Infinity,minLat=+Infinity,maxLon=-Infinity,maxLat=-Infinity;
    for(const d of data){minLon=Math.min(minLon,d.lon);minLat=Math.min(minLat,d.lat);maxLon=Math.max(maxLon,d.lon);maxLat=Math.max(maxLat,d.lat);}
    const nx=Math.max(2, Math.floor((maxLon-minLon)/stepDeg)+2);
    const ny=Math.max(2, Math.floor((maxLat-minLat)/stepDeg)+2);

    const sum=new Float64Array(nx*ny), cnt=new Uint32Array(nx*ny);
    const idx=(ix,iy)=>iy*nx+ix;
    for(const p of data){
      const ix=Math.min(nx-1,Math.max(0,Math.floor((p.lon-minLon)/stepDeg)));
      const iy=Math.min(ny-1,Math.max(0,Math.floor((p.lat-minLat)/stepDeg)));
      const k=idx(ix,iy); sum[k]+=p.z; cnt[k]+=1;
    }

    const zGrid=new Float64Array(nx*ny);
    for(let i=0;i<nx*ny;i++){ zGrid[i] = cnt[i]? (sum[i]/cnt[i]) : zmin; }

    const positions=new Float64Array(nx*ny*3);
    const vcolors =new Uint8Array(nx*ny*4);
    let ptrP=0, ptrC=0;

    for(let iy=0;iy<ny;iy++){
      const lat=minLat+iy*stepDeg;
      for(let ix=0;ix<nx;ix++){
        const lon=minLon+ix*stepDeg;
        const k=idx(ix,iy);
        const zraw = zGrid[k];
        const z = zraw * zExag;
        const c3=Cesium.Cartesian3.fromDegrees(lon,lat,z);
        positions[ptrP++]=c3.x; positions[ptrP++]=c3.y; positions[ptrP++]=c3.z;

        const ci   = colorIndexForZ(zraw, zmin, zmax, bins);
        const col  = colors[ci];
        vcolors[ptrC++]=col[0]; vcolors[ptrC++]=col[1]; vcolors[ptrC++]=col[2]; vcolors[ptrC++]=220;
      }
    }

    const cellsX=nx-1, cellsY=ny-1;
    const indices=new Uint32Array(cellsX*cellsY*2*3);
    let ip=0;
    for(let iy=0;iy<cellsY;iy++){
      for(let ix=0;ix<cellsX;ix++){
        const a=iy*nx+ix, b=a+1, c=a+nx, d=c+1;
        indices[ip++]=a; indices[ip++]=c; indices[ip++]=b;
        indices[ip++]=b; indices[ip++]=c; indices[ip++]=d;
      }
    }

    dtmMeta = {minLon, minLat, stepDeg, nx, ny, zGrid};
    return {positions, indices, vcolors, paletteColors: colors};
  }

  function renderDTM(grid){
    if (!grid) return;
    if (dtmPrimitive){ viewer.scene.primitives.remove(dtmPrimitive); dtmPrimitive=null; }

    const geometry = new Cesium.Geometry({
      attributes:{
        position:new Cesium.GeometryAttribute({
          componentDatatype:Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute:3,
          values:grid.positions
        }),
        color:new Cesium.GeometryAttribute({
          componentDatatype:Cesium.ComponentDatatype.UNSIGNED_BYTE,
          componentsPerAttribute:4,
          values:grid.vcolors,
          normalize:true
        })
      },
      indices:grid.indices,
      primitiveType:Cesium.PrimitiveType.TRIANGLES,
      boundingSphere:Cesium.BoundingSphere.fromVertices(grid.positions),
      vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
    });

    dtmPrimitive = new Cesium.Primitive({
      geometryInstances: new Cesium.GeometryInstance({geometry}),
      appearance: new Cesium.PerInstanceColorAppearance({translucent:true, closed:false}),
      asynchronous: true
    });

    viewer.scene.primitives.add(dtmPrimitive);
  }

  function colorForPoint(z, zmin, zmax, colors){
    const bins=colors.length;
    const idx = colorIndexForZ(z, zmin, zmax, bins);
    const c = colors[idx];
    return new Cesium.Color(c[0]/255,c[1]/255,c[2]/255,0.95);
  }

  function showPoints(colorsForBins){
    pointLayer.removeAll();
    const ps=Math.max(1, Number(pointSizeInp.value)||6);
    const [zmin,zmax]=computeZRange();

    for(let i=0;i<lonlatz.length;i++){
      const p=lonlatz[i], u=rawUTM[i];
      const col = (colorizePoints.checked && colorsForBins)
        ? colorForPoint(p.z, zmin, zmax, colorsForBins)
        : Cesium.Color.CYAN.withAlpha(0.95);
      const pt = pointLayer.add({
        position: Cesium.Cartesian3.fromDegrees(p.lon,p.lat,p.z),
        pixelSize: ps,
        color: col,
        outlineColor: Cesium.Color.WHITE.withAlpha(0.9),
        outlineWidth: 1,
        id:{type:"utm-point",index:i,lon:p.lon,lat:p.lat,z:p.z,E:u.E,N:u.N,Z:u.Z}
      });
      pt.disableDepthTestDistance = pointsOnTop.checked ? Number.POSITIVE_INFINITY : 0.0;
    }
    flyToBounds(lonlatz);
  }

  // ====== Popup titik ======
  const handler=new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  handler.setInputAction((movement)=>{
    const picked=viewer.scene.pick(movement.position);
    if (!picked || !picked.primitive || !picked.primitive.id){ popupEl.style.display="none"; return; }
    const d=picked.primitive.id;
    if (d.type!=="utm-point"){ popupEl.style.display="none"; return; }
    popupEl.innerHTML=`
      <h4>XYZ UTM 49S → WGS84</h4>
      <div class="rowp"><span>Easting</span><span>${d.E.toFixed(3)} m</span></div>
      <div class="rowp"><span>Northing</span><span>${d.N.toFixed(3)} m</span></div>
      <div class="rowp"><span>Z (asli)</span><span>${d.Z.toFixed(3)} m</span></div>
      <div class="rowp"><span>Lon</span><span>${d.lon.toFixed(6)}°</span></div>
      <div class="rowp"><span>Lat</span><span>${d.lat.toFixed(6)}°</span></div>
      <div class="rowp"><span>Z (offset)</span><span>${d.z.toFixed(3)} m</span></div>`;
    popupEl.style.left = movement.position.x + 12 + "px";
    popupEl.style.top  = movement.position.y + 12 + "px";
    popupEl.style.display="block";
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
  viewer.camera.moveStart.addEventListener(()=>{ popupEl.style.display="none"; });

  // ====== Underground toggle ======
  function applyUnderground(on){
    const globe=viewer.scene.globe;
    globe.translucency.enabled=!!on;
    if (on) globe.translucency.frontFaceAlpha=0.5;
    viewer.scene.screenSpaceCameraController.enableCollisionDetection=!on;
  }
  document.getElementById('underground').addEventListener('change',()=>applyUnderground(undergroundChk.checked));
  document.getElementById('pointSize').addEventListener('change', ()=> showPoints(paletteCache));
  document.getElementById('colorizePoints').addEventListener('change', ()=> showPoints(paletteCache));
  document.getElementById('pointsOnTop').addEventListener('change', ()=> showPoints(paletteCache));

  // ====== Load flow ======
  const status = msg => setStatus(msg);

  async function loadAndRenderText(text){
    status('Konversi UTM 49S → WGS84…');
    const {utm,wgs,zMin,zMax}=parseUTM49S(text);
    if (!wgs.length){ status('Gagal parsing. Cek delimiter & format.'); return; }
    rawUTM=utm; lonlatz=wgs; zStats={min:zMin,max:zMax};
    showPoints(null);
    status(`Titik: ${lonlatz.length.toLocaleString()} | Z[min,max]=[${zMin.toFixed(2)}, ${zMax.toFixed(2)}]`);
  }

  let paletteCache=null;

  function computeAndRenderDTM(){
    if (!lonlatz.length){ status('Tidak ada data. Load dulu.'); return; }
    const bins = Math.max(4, Math.min(256, parseInt(binsInp.value)||15));
    const [zmin,zmax] = computeZRange();
    const grid = buildDTMQuantized(lonlatz, gridStepInp.value, zExagInp.value, bins, paletteSel.value, zmin, zmax);
    renderDTM(grid);
    paletteCache = grid.paletteColors;
    drawLegend(paletteCache, zmin, zmax, 6);
    if (colorizePoints.checked) showPoints(paletteCache);
    status(`DTM siap ✔ | Bins=${bins} | Range=[${zmin.toFixed(2)}, ${zmax.toFixed(2)}] m`);
  }

  document.getElementById('btnLoad').addEventListener('click', async ()=>{
    const f=fileInput.files && fileInput.files[0];
    if (!f){ status('Pilih file XYZ/CSV dulu.'); return; }
    const t=await f.text(); await loadAndRenderText(t);
  });
  document.getElementById('btnBuildDTM').addEventListener('click', computeAndRenderDTM);
  document.getElementById('btnRecolor').addEventListener('click', computeAndRenderDTM);

  document.getElementById('btnClear').addEventListener('click', ()=>{
    pointLayer.removeAll();
    if (dtmPrimitive){ viewer.scene.primitives.remove(dtmPrimitive); dtmPrimitive=null; }
    lonlatz=[]; rawUTM=[]; zStats=null; fileInput.value=''; popupEl.style.display='none';
    legendTicks.textContent = ""; const ctx=legendCanvas.getContext('2d'); ctx.clearRect(0,0,legendCanvas.width,legendCanvas.height);
    profileBox.style.display='none'; polyStats.style.display='none';
    clearDrawing();
    status('Bersih. Siap upload baru.');
  });

  document.getElementById('zOffset').addEventListener('change', ()=>{
    if (!rawUTM.length) return;
    const zOff=Number(zOffsetInp.value)||0;
    lonlatz=lonlatz.map((p,i)=>({lon:p.lon,lat:p.lat,z:rawUTM[i].Z+zOff}));
    const zs=lonlatz.map(p=>p.z); zStats={min:Math.min(...zs), max:Math.max(...zs)};
    showPoints(paletteCache);
    if (dtmPrimitive) computeAndRenderDTM();
    status(`Z Offset: ${zOff} m`);
  });

  try{
    const resp=await fetch('./DTM.xyz',{cache:'no-store'});
    if (resp.ok){
      const text=await resp.text();
      await loadAndRenderText(text);
      status('Auto-load DTM.xyz ✔ — klik "Buat DTM" untuk pewarnaan');
    }else{
      status('DTM.xyz tidak ditemukan. Silakan unggah file.');
    }
  }catch(e){ status('Gagal membaca DTM.xyz. Silakan unggah file.'); console.warn(e); }

  // =========================
  // ==== GAMBAR & ANALISIS ==
  // =========================
  function clearDrawing(){
    drawPositions = [];
    if (activePolyline){ viewer.entities.remove(activePolyline); activePolyline=null; }
    if (activePolygon){ viewer.entities.remove(activePolygon); activePolygon=null; }
  }

  // entity helper
  const entityLayer = viewer.entities;

  function startLine(){
    clearDrawing();
    activePolyline = entityLayer.add({
      polyline:{
        positions: new Cesium.CallbackProperty(()=> drawPositions, false),
        width:3,
        material: Cesium.Color.CYAN
      }
    });
  }
  function startPolygon(){
    clearDrawing();
    activePolygon = entityLayer.add({
      polygon:{
        hierarchy: new Cesium.CallbackProperty(()=> new Cesium.PolygonHierarchy(drawPositions), false),
        material: Cesium.Color.fromCssColorString('#00bcd44d'),
        outline:true, outlineColor: Cesium.Color.CYAN
      }
    });
  }

  drawModeSel.addEventListener('change', ()=>{
    profileBox.style.display='none'; polyStats.style.display='none';
    if (drawModeSel.value==='line') startLine();
    else if (drawModeSel.value==='polygon') startPolygon();
    else clearDrawing();
  });

  btnResetDraw.addEventListener('click', ()=>{
    clearDrawing();
    if (drawModeSel.value==='line') startLine();
    if (drawModeSel.value==='polygon') startPolygon();
    profileBox.style.display='none'; polyStats.style.display='none';
  });

  // click handler for drawing
  const drawHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  drawHandler.setInputAction((movement)=>{
    if (drawModeSel.value==='none') return;
    const cartesian = viewer.scene.pickPosition(movement.position) ||
                      viewer.camera.pickEllipsoid(movement.position, Cesium.Ellipsoid.WGS84);
    if (!cartesian) return;
    const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(cartesian);
    drawPositions.push(Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0));
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  // double click to finish & compute
  drawHandler.setInputAction((movement)=>{
    if (drawModeSel.value==='line'){
      computeProfileFromLine();
    } else if (drawModeSel.value==='polygon'){
      computeAreaVolumeFromPolygon();
    }
  }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

  // ==== Interpolasi elevasi dari DTM grid ====
  function zAtLonLat(lon, lat){
    if (!dtmMeta) return null;
    const {minLon,minLat,stepDeg,nx,ny,zGrid} = dtmMeta;
    const ix = (lon - minLon)/stepDeg;
    const iy = (lat - minLat)/stepDeg;
    const i0 = Math.floor(ix), j0 = Math.floor(iy);
    const i1 = i0+1, j1 = j0+1;
    if (i0<0||j0<0||i1>=nx||j1>=ny) return null;
    const tx = ix - i0, ty = iy - j0;
    const idx = (i,j)=> j*nx + i;
    const z00=zGrid[idx(i0,j0)], z10=zGrid[idx(i1,j0)], z01=zGrid[idx(i0,j1)], z11=zGrid[idx(i1,j1)];
    const z0 = z00*(1-tx)+z10*tx;
    const z1 = z01*(1-tx)+z11*tx;
    return z0*(1-ty)+z1*ty;
  }

  // ==== Profil sepanjang garis ====
  function computeProfileFromLine(){
    if (!dtmMeta){ alert('Bangun DTM dulu.'); return; }
    if (drawPositions.length < 2){ alert('Gambar minimal dua titik untuk profil.'); return; }
    const samples = Math.max(50, Math.min(2000, parseInt(profileSamplesInp.value)||200));
    // kumpulkan path (lon,lat)
    const pts=[];
    for (const p of drawPositions){
      const c = Cesium.Cartographic.fromCartesian(p);
      pts.push([Cesium.Math.toDegrees(c.longitude), Cesium.Math.toDegrees(c.latitude)]);
    }
    // hitung panjang segmen
    const cartos = drawPositions.map(p=>Cesium.Cartographic.fromCartesian(p));
    const geod = new Cesium.EllipsoidGeodesic();
    const segLen=[];
    let total=0;
    for (let i=0;i<cartos.length-1;i++){
      geod.setEndPoints(cartos[i], cartos[i+1]);
      const d=geod.surfaceDistance; segLen.push(d); total+=d;
    }
    // sample sepanjang
    const xs=[], zs=[];
    for (let s=0;s<samples;s++){
      const dist = total * (s/(samples-1));
      // cari segmen
      let acc=0, i=0;
      while (i<segLen.length && acc+segLen[i]<dist){ acc+=segLen[i]; i++; }
      const t = (segLen[i]===0)?0: (dist-acc)/segLen[i];
      // interp cartographic
      const a = cartos[i], b = cartos[i+1];
      geod.setEndPoints(a,b);
      const carto = geod.interpolateUsingSurfaceDistance(segLen[i]*t);
      const lon = Cesium.Math.toDegrees(carto.longitude);
      const lat = Cesium.Math.toDegrees(carto.latitude);
      const z = zAtLonLat(lon, lat);
      xs.push(dist); zs.push(z);
    }
    drawProfile(xs, zs);
  }

  function drawProfile(xs, zs){
    // stats
    const zmin = Math.min(...zs.filter(v=>v!=null));
    const zmax = Math.max(...zs.filter(v=>v!=null));
    const len  = xs[xs.length-1];
    // plot ke canvas
    const cv = profileCanvas, ctx=cv.getContext('2d');
    ctx.clearRect(0,0,cv.width,cv.height);
    // axes
    ctx.strokeStyle="#3b82f6"; ctx.lineWidth=1;
    ctx.strokeRect(36,10,cv.width-46,cv.height-36);
    // map x->px, z->py
    const px = d => 36 + d/len*(cv.width-46);
    const py = z => {
      const t=(z - zmin)/Math.max(1e-9,(zmax - zmin));
      return 10 + (1-t)*(cv.height-36);
    };
    // grid
    ctx.strokeStyle="#223055"; ctx.lineWidth=1;
    for(let i=1;i<=4;i++){
      const y=10 + i*(cv.height-36)/5;
      ctx.beginPath(); ctx.moveTo(36,y); ctx.lineTo(cv.width-10,y); ctx.stroke();
    }
    // line
    ctx.strokeStyle="#9fb3ff"; ctx.lineWidth=2;
    ctx.beginPath();
    for (let i=0;i<xs.length;i++){
      if (zs[i]==null) continue;
      const x=px(xs[i]); const y=py(zs[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    // labels
    ctx.fillStyle="#eaeef6"; ctx.font="11px system-ui";
    ctx.fillText(`0 m`, 36, cv.height-8);
    ctx.textAlign="right";
    ctx.fillText(`${len.toFixed(1)} m`, cv.width-12, cv.height-8);
    ctx.textAlign="left";
    ctx.fillText(`z[min,max]=[${zmin.toFixed(2)}, ${zmax.toFixed(2)}] m`, 40, 22);

    profileBox.style.display='block';
    profileStats.innerHTML = `Panjang: <b>${(len/1000).toFixed(3)} km</b> · Zmin: <b>${zmin.toFixed(2)} m</b> · Zmax: <b>${zmax.toFixed(2)} m</b>`;
  }

  // ==== Area & Volume dari poligon ====
  function computeAreaVolumeFromPolygon(){
    if (!dtmMeta){ alert('Bangun DTM dulu.'); return; }
    if (drawPositions.length < 3){ alert('Gambar minimal tiga titik untuk poligon.'); return; }

    // vertices lon/lat
    const verts = drawPositions.map(p=>{
      const c=Cesium.Cartographic.fromCartesian(p);
      return [Cesium.Math.toDegrees(c.longitude), Cesium.Math.toDegrees(c.latitude)];
    });

    // area (planar ENU di centroid)
    const centroidLon = verts.reduce((s,v)=>s+v[0],0)/verts.length;
    const centroidLat = verts.reduce((s,v)=>s+v[1],0)/verts.length;
    const cenCart = Cesium.Cartesian3.fromDegrees(centroidLon, centroidLat, 0);
    const enu = Cesium.Transforms.eastNorthUpToFixedFrame(cenCart);
    const inv = Cesium.Matrix4.inverse(enu, new Cesium.Matrix4());

    function lonlatToEN(v){
      const cart = Cesium.Cartesian3.fromDegrees(v[0], v[1], 0);
      return Cesium.Matrix4.multiplyByPoint(inv, cart, new Cesium.Cartesian3());
    }
    const enPts = verts.map(lonlatToEN);
    // shoelace
    let area=0;
    for (let i=0;i<enPts.length;i++){
      const a=enPts[i], b=enPts[(i+1)%enPts.length];
      area += (a.x*b.y - b.x*a.y);
    }
    area = Math.abs(area)*0.5; // m²

    // volume di atas elev. referensi (hanya positif)
    const {minLon,minLat,stepDeg,nx,ny,zGrid} = dtmMeta;
    const ref = Number(refElevInp.value)||0;

    // helper: point in polygon (ray casting) untuk lon/lat
    function pointInPoly(lon,lat){
      let inside=false;
      for (let i=0,j=verts.length-1;i<verts.length;j=i++){
        const xi=verts[i][0], yi=verts[i][1];
        const xj=verts[j][0], yj=verts[j][1];
        const intersect = ((yi>lat)!=(yj>lat)) && (lon < (xj-xi)*(lat-yi)/(yj-yi+1e-12)+xi);
        if (intersect) inside=!inside;
      }
      return inside;
    }

    // loop grid cell center
    let volume=0, coveredArea=0, count=0;
    for (let j=0;j<ny;j++){
      const lat = minLat + j*stepDeg;
      // konversi step deg ke meter, approx
      const latMeters = 111320 * stepDeg;
      const lonMeters = 111320 * Math.cos(lat*Math.PI/180) * stepDeg;
      const cellArea = latMeters * lonMeters;

      for (let i=0;i<nx;i++){
        const lon = minLon + i*stepDeg;
        if (!pointInPoly(lon,lat)) continue;
        const z = zGrid[j*nx + i];
        const h = Math.max(0, z - ref);
        volume += h * cellArea;
        coveredArea += cellArea;
        count++;
      }
    }

    polyStats.style.display='block';
    polyStats.innerHTML = `
      <div><b>Luas</b>: ${(area).toFixed(2)} m² (${(area/10000).toFixed(4)} ha)</div>
      <div><b>Volume (z > ${ref.toFixed(2)} m)</b>: ${(volume).toFixed(2)} m³</div>
      <div class="muted">Sel terhitung: ${count.toLocaleString()} | Step: ${ (dtmMeta.stepDeg).toFixed(6)}°</div>
    `;
  }

})();
</script>
</body>
</html>
