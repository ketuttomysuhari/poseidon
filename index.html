<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>UTM 49S XYZ → CesiumJS | DTM Binned + Buildings</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css">
<script>window.CESIUM_BASE_URL="https://unpkg.com/cesium/Build/Cesium/";</script>
<script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>
<script src="https://cdn.jsdelivr.net/npm/proj4@2.9.1/dist/proj4.js"></script>
<style>
  html,body,#app{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#0b0f19;color:#eaeef6}
  #toolbar{position:absolute;z-index:10;top:12px;left:12px;right:12px;background:rgba(18,24,38,.92);border:1px solid #1f2a44;border-radius:12px;padding:12px;display:grid;gap:10px}
  #toolbar .row{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:10px}
  #toolbar label{font-size:12px;opacity:.9}
  #toolbar input,#toolbar select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #2a385e;background:#0f1526;color:#eaeef6}
  #toolbar input[type=file]{color:#9fb3ff}
  #toolbar button{background:linear-gradient(180deg,#3b82f6,#2563eb);border:none;color:#fff;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  #toolbar button.secondary{background:#223055}
  #toolbar .small{font-size:12px;opacity:.85}
  #status{font-size:12px;color:#9fb3ff}
  #cesiumContainer{position:absolute;inset:0}
  .chip{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #2a385e;background:#0f1526;font-size:12px}
  .switch{display:flex;gap:8px;align-items:center}
  #popup{position:absolute;z-index:20;min-width:220px;max-width:320px;background:rgba(14,18,30,.98);border:1px solid #223055;border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,.35);padding:10px;display:none;pointer-events:none}
  #popup h4{margin:0 0 6px 0;font-size:13px;color:#c7d2fe}
  #popup .row{font-size:12px;display:flex;justify-content:space-between;gap:8px}
  #legend{position:absolute;right:12px;bottom:12px;z-index:15;background:rgba(18,24,38,.92);border:1px solid #1f2a44;border-radius:10px;padding:10px}
  #legend h5{margin:0 0 6px 0;font-size:12px;color:#c7d2fe}
  #legend canvas{display:block}
</style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
      <input id="fileInput" type="file" accept=".xyz,.txt,.csv" />
      <button id="btnLoad">Tampilkan Titik</button>
      <button id="btnBuildDTM">Buat DTM</button>
      <button id="btnRecolor" class="secondary">Recolor</button>
      <button id="btnClear" class="secondary">Bersihkan</button>
      <span id="status" class="chip">Auto-load <b>DTM.xyz</b> jika ada…</span>
    </div>

    <div class="row">
      <div>
        <label>Delimiter</label>
        <select id="delimiter">
          <option value="auto" selected>Auto (spasi/komma)</option>
          <option value="comma">Comma</option>
          <option value="space">Whitespace</option>
        </select>
      </div>

      <div>
        <label>Z Offset (m)</label>
        <input id="zOffset" type="number" value="0" step="0.1" />
      </div>

      <div>
        <label>Point Size</label>
        <input id="pointSize" type="number" value="6" min="1" step="1" />
      </div>

      <div>
        <label>Points: Always on Top</label>
        <div class="switch"><input id="pointsOnTop" type="checkbox" checked /><span class="small">titik tak tertutup terrain</span></div>
      </div>

      <div>
        <label>Grid Step (deg)</label>
        <input id="gridStepDeg" type="number" value="0.0005" step="0.0001" />
      </div>

      <div>
        <label>Z Exaggeration (DTM)</label>
        <input id="zExag" type="number" value="1.0" step="0.1" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Bins</label>
        <input id="bins" type="number" value="15" min="4" max="64" step="1" />
      </div>
      <div>
        <label>Rentang Z</label>
        <div class="switch"><input id="autoZRange" type="checkbox" checked /><span class="small">Auto (pakai min/max data)</span></div>
      </div>
      <div>
        <label>Z Min, Z Max (manual)</label>
        <input id="zMinMax" type="text" placeholder="mis. 2.64, 11.19" />
      </div>
      <div>
        <label>Underground Mode</label>
        <div class="switch"><input id="underground" type="checkbox" /><span class="small">terrain transparan</span></div>
      </div>
      <div>
        <label>Color Set</label>
        <select id="palette">
          <option value="bgyor" selected>Biru→Hijau→Kuning→Oranye→Merah</option>
          <option value="jet">Jet (mirip MATLAB)</option>
          <option value="viridis">Viridis (perseptual)</option>
        </select>
      </div>
      <div>
        <label>Warna Titik = Warna Bin</label>
        <div class="switch"><input id="colorizePoints" type="checkbox" checked /><span class="small">samakan dengan DTM</span></div>
      </div>
    </div>

    <div class="small">Data diasumsikan <b>UTM 49S (EPSG:32749)</b> → otomatis ke WGS84. 
    Contoh dari gambar Anda: set <b>Bins=15</b>, uncheck Auto, isi <b>2.64, 11.19</b>, lalu klik <b>Buat DTM</b>.</div>
  </div>

  <div id="cesiumContainer"></div>

  <!-- Legend -->
  <div id="legend">
    <h5>Elevation (m)</h5>
    <canvas id="legendCanvas" width="56" height="260"></canvas>
    <div id="legendTicks" class="small" style="margin-top:6px"></div>
  </div>

  <!-- Popup -->
  <div id="popup"></div>
</div>

<script>
(async function(){
  // === Ion token
  Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJhNGQwNTBlZS1iOGVlLTQxZDgtODdiMC03YWQ1ZGUzYWFjZTQiLCJpZCI6MjUyMDkzLCJpYXQiOjE3NjA0MTgyNjB9.N9LrYm3UyvJs5Qgkm2P2DDbIReiWGp1MGOqz-fwfHTc";

  // === Viewer + 3D Terrain
  const viewer = new Cesium.Viewer('cesiumContainer', {
    terrainProvider: await Cesium.createWorldTerrainAsync(),
    baseLayerPicker: true, geocoder: false, homeButton: true,
    animation: false, timeline: false, sceneModePicker: true, navigationHelpButton: false
  });
  viewer.scene.globe.depthTestAgainstTerrain = false;

  // === Tambahkan OSM Buildings
  try {
    const osmBuildings = await Cesium.createOsmBuildingsAsync();
    viewer.scene.primitives.add(osmBuildings);
  } catch (e) {
    console.warn('Gagal memuat OSM Buildings:', e);
  }

  // === CRS
  const UTM49S = "+proj=utm +zone=49 +south +datum=WGS84 +units=m +no_defs";
  const WGS84  = "+proj=longlat +datum=WGS84 +no_defs";

  // === Layers & state
  const pointLayer = new Cesium.PointPrimitiveCollection();
  viewer.scene.primitives.add(pointLayer);
  let dtmPrimitive = null;

  let lonlatz = [];   // {lon,lat,z} offset-applied
  let rawUTM  = [];   // {E,N,Z}
  let zStats  = null; // {min,max}

  // === UI
  const $ = id => document.getElementById(id);
  const statusEl=$("status"), fileInput=$("fileInput"), btnLoad=$("btnLoad"),
        btnBuildDTM=$("btnBuildDTM"), btnRecolor=$("btnRecolor"), btnClear=$("btnClear");
  const delimiterSel=$("delimiter"), zExagInp=$("zExag"), gridStepInp=$("gridStepDeg");
  const pointSizeInp=$("pointSize"), zOffsetInp=$("zOffset"),
        undergroundChk=$("underground"), pointsOnTop=$("pointsOnTop"),
        binsInp=$("bins"), autoZRange=$("autoZRange"), zMinMax=$("zMinMax"),
        paletteSel=$("palette"), colorizePoints=$("colorizePoints");
  const popupEl=$("popup"), legendCanvas=$("legendCanvas"), legendTicks=$("legendTicks");
  const setStatus = html => statusEl.innerHTML = html;

  // === Helpers
  function parseLine(line, mode){
    let parts;
    if (mode==="comma") parts=line.split(",");
    else if (mode==="space") parts=line.trim().split(/\s+/);
    else parts = line.includes(",") ? line.split(",") : line.trim().split(/\s+/);
    if (parts.length < 3) return null;
    return parts.slice(0,3).map(v=>parseFloat(v));
  }

  function parseUTM49S(text){
    const lines=text.split(/\r?\n/);
    const utm=[], wgs=[];
    const zOffset=Number(zOffsetInp.value)||0;
    let zMin=+Infinity, zMax=-Infinity;

    for (const raw of lines){
      const line=raw.trim(); if (!line) continue;
      if (!/[-+0-9.]/.test(line[0])) continue;
      const v=parseLine(line, delimiterSel.value); if (!v) continue;
      let [E,N,Z]=v; if (isNaN(E)||isNaN(N)||isNaN(Z)) continue;
      const [lon,lat]=proj4(UTM49S, WGS84, [E,N]);
      const zAdj=Z + zOffset;
      zMin=Math.min(zMin,zAdj); zMax=Math.max(zMax,zAdj);
      utm.push({E,N,Z}); wgs.push({lon,lat,z:zAdj});
    }
    return {utm,wgs,zMin,zMax};
  }

  function flyToBounds(data){
    if (!data.length) return;
    let minLon=+Infinity,minLat=+Infinity,maxLon=-Infinity,maxLat=-Infinity;
    for (const p of data){
      minLon=Math.min(minLon,p.lon); minLat=Math.min(minLat,p.lat);
      maxLon=Math.max(maxLon,p.lon); maxLat=Math.max(maxLat,p.lat);
    }
    const rect=Cesium.Rectangle.fromDegrees(minLon,minLat,maxLon,maxLat);
    viewer.camera.flyTo({destination:rect,duration:1.2});
  }

  // === palettes
  function hex(h){const v=h.replace('#','');return [parseInt(v.slice(0,2),16),parseInt(v.slice(2,4),16),parseInt(v.slice(4,6),16)];}
  function lerp(a,b,t){return a+(b-a)*t;}
  function lerpC(c1,c2,t){return [Math.round(lerp(c1[0],c2[0],t)),Math.round(lerp(c1[1],c2[1],t)),Math.round(lerp(c1[2],c2[2],t))];}
  function makePalette(name, n){
    const arr=[];
    if (name==="viridis"){
      const stops=[[68,1,84],[59,82,139],[33,145,140],[94,201,98],[253,231,37]];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    } else if (name==="jet"){
      const stops=[[0,0,131],[0,60,170],[5,255,255],[255,255,0],[250,0,0],[128,0,0]];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    } else {
      const stops=[hex("#0000ff"),hex("#00ff00"),hex("#ffff00"),hex("#ff9900"),hex("#ff0000")];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    }
    return arr;
  }

  function computeZRange(){
    if (autoZRange.checked || !zMinMax.value.trim()){
      return [zStats?.min ?? Math.min(...lonlatz.map(p=>p.z)),
              zStats?.max ?? Math.max(...lonlatz.map(p=>p.z))];
    }
    const parts=zMinMax.value.split(',').map(s=>parseFloat(s.trim()));
    if (parts.length>=2 && parts.every(v=>!isNaN(v))) return [parts[0],parts[1]];
    return [Math.min(...lonlatz.map(p=>p.z)), Math.max(...lonlatz.map(p=>p.z))];
  }

  // === legend
  function drawLegend(colors, zmin, zmax, ticks=6){
    const ctx=legendCanvas.getContext('2d');
    const w=legendCanvas.width, h=legendCanvas.height;
    ctx.clearRect(0,0,w,h);
    const n=colors.length;
    for(let i=0;i<n;i++){
      const c=colors[n-1-i];
      ctx.fillStyle=`rgb(${c[0]},${c[1]},${c[2]})`;
      const y=i*(h/n);
      ctx.fillRect(24,y,w-24,h/n+1);
    }
    ctx.fillStyle="#eaeef6"; ctx.font="11px system-ui";
    ctx.textAlign="right"; ctx.textBaseline="middle";
    for(let i=0;i<ticks;i++){
      const t=i/(ticks-1);
      const z=lerp(zmin,zmax,1-t);
      const y=lerp(0,h,t);
      ctx.fillRect(20,y,4,1);
      ctx.fillText(z.toFixed(1)+" m",18,y);
    }
    legendTicks.textContent = `Bins: ${n}  |  Range: ${zmin.toFixed(2)} – ${zmax.toFixed(2)} m`;
  }

  function colorIndexForZ(z, zmin, zmax, bins){
    if (zmax===zmin) return 0;
    let t=(z - zmin)/(zmax - zmin);
    t=Math.max(0,Math.min(1,t));
    return Math.min(bins-1, Math.floor(t*bins));
  }

  // === build DTM quantized (per-vertex color)
  function buildDTMQuantized(data, stepDeg, zExag, bins, palette, zmin, zmax){
    stepDeg = Math.max(1e-6, Number(stepDeg)||0.0005);
    zExag   = Number(zExag)||1.0;
    bins    = Math.max(4, Math.min(256, Math.floor(bins)||15));
    const colors = makePalette(palette, bins);

    // bounds
    let minLon=+Infinity,minLat=+Infinity,maxLon=-Infinity,maxLat=-Infinity;
    for(const d of data){minLon=Math.min(minLon,d.lon);minLat=Math.min(minLat,d.lat);maxLon=Math.max(maxLon,d.lon);maxLat=Math.max(maxLat,d.lat);}
    const nx=Math.max(2, Math.floor((maxLon-minLon)/stepDeg)+2);
    const ny=Math.max(2, Math.floor((maxLat-minLat)/stepDeg)+2);

    const sum=new Float64Array(nx*ny), cnt=new Uint32Array(nx*ny);
    const idx=(ix,iy)=>iy*nx+ix;
    for(const p of data){
      const ix=Math.min(nx-1,Math.max(0,Math.floor((p.lon-minLon)/stepDeg)));
      const iy=Math.min(ny-1,Math.max(0,Math.floor((p.lat-minLat)/stepDeg)));
      const k=idx(ix,iy); sum[k]+=p.z; cnt[k]+=1;
    }

    const positions=new Float64Array(nx*ny*3);
    const vcolors =new Uint8Array(nx*ny*4);
    let ptrP=0, ptrC=0;

    for(let iy=0;iy<ny;iy++){
      const lat=minLat+iy*stepDeg;
      for(let ix=0;ix<nx;ix++){
        const lon=minLon+ix*stepDeg;
        const k=idx(ix,iy);
        const zraw = cnt[k]?(sum[k]/cnt[k]):zmin;
        const z = zraw * zExag;
        const c3=Cesium.Cartesian3.fromDegrees(lon,lat,z);
        positions[ptrP++]=c3.x; positions[ptrP++]=c3.y; positions[ptrP++]=c3.z;

        const ci   = colorIndexForZ(zraw, zmin, zmax, bins);
        const col  = colors[ci];
        vcolors[ptrC++]=col[0]; vcolors[ptrC++]=col[1]; vcolors[ptrC++]=col[2]; vcolors[ptrC++]=220;
      }
    }

    const cellsX=nx-1, cellsY=ny-1;
    const indices=new Uint32Array(cellsX*cellsY*2*3);
    let ip=0;
    for(let iy=0;iy<cellsY;iy++){
      for(let ix=0;ix<cellsX;ix++){
        const a=iy*nx+ix, b=a+1, c=a+nx, d=c+1;
        indices[ip++]=a; indices[ip++]=c; indices[ip++]=b;
        indices[ip++]=b; indices[ip++]=c; indices[ip++]=d;
      }
    }
    return {positions, indices, vcolors, paletteColors: colors};
  }

  // === RENDER (FIX): gunakan PerInstanceColorAppearance
  function renderDTM(grid){
    if (!grid) return;
    if (dtmPrimitive){ viewer.scene.primitives.remove(dtmPrimitive); dtmPrimitive=null; }

    const geometry = new Cesium.Geometry({
      attributes:{
        position:new Cesium.GeometryAttribute({
          componentDatatype:Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute:3,
          values:grid.positions
        }),
        color:new Cesium.GeometryAttribute({
          componentDatatype:Cesium.ComponentDatatype.UNSIGNED_BYTE,
          componentsPerAttribute:4,
          values:grid.vcolors,
          normalize:true
        })
      },
      indices:grid.indices,
      primitiveType:Cesium.PrimitiveType.TRIANGLES,
      boundingSphere:Cesium.BoundingSphere.fromVertices(grid.positions),
      vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
    });

    dtmPrimitive = new Cesium.Primitive({
      geometryInstances: new Cesium.GeometryInstance({geometry}),
      appearance: new Cesium.PerInstanceColorAppearance({translucent:true, closed:false}),
      asynchronous: true
    });

    viewer.scene.primitives.add(dtmPrimitive);
  }

  function colorForPoint(z, zmin, zmax, colors){
    const bins=colors.length;
    const ci = colorIndexForZ(z, zmin, zmax, bins);
    const c  = colors[ci];
    return new Cesium.Color(c[0]/255,c[1]/255,c[2]/255,0.95);
  }

  function showPoints(colorsForBins){
    pointLayer.removeAll();
    const ps=Math.max(1, Number(pointSizeInp.value)||6);
    const [zmin,zmax]=computeZRange();

    for(let i=0;i<lonlatz.length;i++){
      const p=lonlatz[i], u=rawUTM[i];
      const col = (colorizePoints.checked && colorsForBins)
        ? colorForPoint(p.z, zmin, zmax, colorsForBins)
        : Cesium.Color.CYAN.withAlpha(0.95);
      const pt = pointLayer.add({
        position: Cesium.Cartesian3.fromDegrees(p.lon,p.lat,p.z),
        pixelSize: ps,
        color: col,
        outlineColor: Cesium.Color.WHITE.withAlpha(0.9),
        outlineWidth: 1,
        id:{type:"utm-point",index:i,lon:p.lon,lat:p.lat,z:p.z,E:u.E,N:u.N,Z:u.Z}
      });
      pt.disableDepthTestDistance = pointsOnTop.checked ? Number.POSITIVE_INFINITY : 0.0;
    }
    flyToBounds(lonlatz);
  }

  // Popup
  const handler=new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  handler.setInputAction((movement)=>{
    const picked=viewer.scene.pick(movement.position);
    if (!picked || !picked.primitive || !picked.primitive.id){ popupEl.style.display="none"; return; }
    const d=picked.primitive.id;
    if (d.type!=="utm-point"){ popupEl.style.display="none"; return; }
    popupEl.innerHTML=`
      <h4>XYZ UTM 49S → WGS84</h4>
      <div class="row"><span>Easting</span><span>${d.E.toFixed(3)} m</span></div>
      <div class="row"><span>Northing</span><span>${d.N.toFixed(3)} m</span></div>
      <div class="row"><span>Z (asli)</span><span>${d.Z.toFixed(3)} m</span></div>
      <div class="row"><span>Lon</span><span>${d.lon.toFixed(6)}°</span></div>
      <div class="row"><span>Lat</span><span>${d.lat.toFixed(6)}°</span></div>
      <div class="row"><span>Z (offset)</span><span>${d.z.toFixed(3)} m</span></div>`;
    popupEl.style.left = movement.position.x + 12 + "px";
    popupEl.style.top  = movement.position.y + 12 + "px";
    popupEl.style.display="block";
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
  viewer.camera.moveStart.addEventListener(()=>{ popupEl.style.display="none"; });

  // Underground & points on top toggles
  function applyUnderground(on){
    const globe=viewer.scene.globe;
    globe.translucency.enabled=!!on;
    if (on) globe.translucency.frontFaceAlpha=0.5;
    viewer.scene.screenSpaceCameraController.enableCollisionDetection=!on;
  }
  undergroundChk.addEventListener('change',()=>applyUnderground(undergroundChk.checked));
  pointsOnTop.addEventListener('change',()=>showPoints(dtmPrimitive && dtmPrimitive._appearance ? null : paletteForLegend));

  // Load + actions
  async function loadAndRenderText(text){
    setStatus('Konversi UTM 49S → WGS84…');
    const {utm,wgs,zMin,zMax}=parseUTM49S(text);
    if (!wgs.length){ setStatus('Gagal parsing. Cek delimiter & format.'); return; }
    rawUTM=utm; lonlatz=wgs; zStats={min:zMin,max:zMax};
    showPoints(null);
    setStatus(`Titik: ${lonlatz.length.toLocaleString()} | Z[min,max]=[${zMin.toFixed(2)}, ${zMax.toFixed(2)}]`);
  }

  let paletteForLegend=null; // cache palette terakhir

  function buildAndRenderDTM(){
    if (!lonlatz.length){ setStatus('Tidak ada data. Load dulu.'); return; }
    const bins = Math.max(4, Math.min(256, parseInt(binsInp.value)||15));
    const [zmin,zmax] = computeZRange();
    const grid = buildDTMQuantized(lonlatz, gridStepInp.value, zExagInp.value, bins, paletteSel.value, zmin, zmax);
    renderDTM(grid);
    paletteForLegend = grid.paletteColors;
    drawLegend(paletteForLegend, zmin, zmax, 6);
    if (colorizePoints.checked) showPoints(paletteForLegend);
    setStatus(`DTM siap ✔  |  Bins=${bins}  |  Range=[${zmin.toFixed(2)}, ${zmax.toFixed(2)}] m`);
  }

  $("pointSize").addEventListener('change', ()=> showPoints(paletteForLegend));
  $("colorizePoints").addEventListener('change', ()=> showPoints(paletteForLegend));

  btnLoad.addEventListener('click', async ()=>{
    const f=fileInput.files && fileInput.files[0];
    if (!f){ setStatus('Pilih file XYZ/CSV dulu.'); return; }
    const t=await f.text(); await loadAndRenderText(t);
  });
  btnBuildDTM.addEventListener('click', buildAndRenderDTM);
  btnRecolor.addEventListener('click', buildAndRenderDTM);

  btnClear.addEventListener('click', ()=>{
    pointLayer.removeAll();
    if (dtmPrimitive){ viewer.scene.primitives.remove(dtmPrimitive); dtmPrimitive=null; }
    lonlatz=[]; rawUTM=[]; zStats=null; fileInput.value=''; popupEl.style.display='none';
    legendTicks.textContent = ""; const ctx=legendCanvas.getContext('2d'); ctx.clearRect(0,0,legendCanvas.width,legendCanvas.height);
    setStatus('Bersih. Siap upload baru.');
  });

  zOffsetInp.addEventListener('change', ()=>{
    if (!rawUTM.length) return;
    const zOff=Number(zOffsetInp.value)||0;
    lonlatz=lonlatz.map((p,i)=>({lon:p.lon,lat:p.lat,z:rawUTM[i].Z+zOff}));
    const zs=lonlatz.map(p=>p.z); zStats={min:Math.min(...zs), max:Math.max(...zs)};
    showPoints(paletteForLegend);
    if (dtmPrimitive) buildAndRenderDTM();
    setStatus(`Z Offset: ${zOff} m`);
  });

  // Auto-load DTM.xyz bila ada
  try{
    const resp=await fetch('./DTM.xyz',{cache:'no-store'});
    if (resp.ok){
      const text=await resp.text();
      await loadAndRenderText(text);
      setStatus('Auto-load DTM.xyz ✔ — klik "Buat DTM" untuk pewarnaan');
    }else{
      setStatus('DTM.xyz tidak ditemukan. Silakan unggah file.');
    }
  }catch(e){
    setStatus('Gagal membaca DTM.xyz. Silakan unggah file.');
    console.warn(e);
  }
})();
</script>
</body>
</html>
