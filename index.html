<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Poseidon WebGIS</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css">
<script>window.CESIUM_BASE_URL="https://unpkg.com/cesium/Build/Cesium/";</script>
<script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>
<script src="https://cdn.jsdelivr.net/npm/proj4@2.9.1/dist/proj4.js"></script>
<style>
  :root{ --sidebar-w: 340px; }
  html,body{height:100%;margin:0;background:#0b0f19;color:#eaeef6;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #layout{display:grid;grid-template-columns:var(--sidebar-w) 1fr;grid-template-rows:100%;height:100%}
  /* Sidebar */
  #sidebar{background:#0d1324;border-right:1px solid #1f2a44;display:flex;flex-direction:column;min-width:280px;max-width:520px}
  #brand{display:flex;align-items:center;gap:10px;padding:14px 14px;border-bottom:1px solid #1f2a44}
  #brand img{width:28px;height:28px;object-fit:contain}
  #brand h1{font-size:14px;margin:0;color:#c7d2fe;letter-spacing:.3px}
  #controls{padding:12px;overflow:auto;display:flex;flex-direction:column;gap:12px}
  .card{border:1px solid #1f2a44;border-radius:12px;background:#0f1526;padding:12px}
  .card h3{margin:0 0 10px 0;font-size:12px;text-transform:uppercase;letter-spacing:.08em;color:#9fb3ff}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  label{font-size:12px;opacity:.9}
  input,select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #2a385e;background:#0b1120;color:#eaeef6}
  input[type=file]{color:#9fb3ff}
  .btn{background:linear-gradient(180deg,#3b82f6,#2563eb);border:none;color:#fff;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  .btn.secondary{background:#223055}
  .stack{display:flex;flex-wrap:wrap;gap:8px}
  .switch{display:flex;gap:8px;align-items:center}
  .muted{font-size:12px;opacity:.8}
  .status{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #2a385e;background:#0b1120;font-size:12px;color:#9fb3ff}
  /* Map panel */
  #map{position:relative}
  #cesiumContainer{position:absolute;inset:0}
  /* Popup */
  #popup{position:absolute;z-index:20;min-width:220px;max-width:320px;background:rgba(14,18,30,.98);border:1px solid #223055;border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,.35);padding:10px;display:none;pointer-events:none}
  #popup h4{margin:0 0 6px 0;font-size:13px;color:#c7d2fe}
  #popup .rowp{font-size:12px;display:flex;justify-content:space-between;gap:8px}
  /* Legend: mengambang di kanan bawah map */
  #legend{position:absolute;right:12px;bottom:12px;z-index:15;background:rgba(18,24,38,.92);border:1px solid #1f2a44;border-radius:10px;padding:10px}
  #legend h5{margin:0 0 6px 0;font-size:12px;color:#c7d2fe}
  #legend canvas{display:block;border:1px solid #1f2a44;border-radius:8px;background:#0b1120}
  #legend .muted{margin-top:6px}
  /* Sembunyikan watermark Cesium */
  .cesium-widget-credits{display:none !important}

  #brand img.poseidon-logo {
  height: 70px;          /* atur besar logo */
  width: auto;
  border-radius: 12px;
  object-fit: contain;
}

</style>
</head>
<body>
<div id="layout">
  <!-- ========== SIDEBAR ========== -->
  <aside id="sidebar">
    <div id="brand">
      <img src="poseidon.png" class="poseidon-logo" alt="Poseidon" />
    </div>
    

    <div id="controls">
      <div class="card">
        <h3>Data</h3>
        <div class="row">
          <div>
            <label>File XYZ</label>
            <input id="fileInput" type="file" accept=".xyz,.txt,.csv" />
          </div>
          <div>
            <label>Delimiter</label>
            <select id="delimiter">
              <option value="auto" selected>Auto (spasi/komma)</option>
              <option value="comma">Comma</option>
              <option value="space">Whitespace</option>
            </select>
          </div>
        </div>
        <div class="stack" style="margin-top:8px">
          <button class="btn" id="btnLoad">Tampilkan Titik</button>
          <button class="btn" id="btnBuildDTM">Buat DTM</button>
          <button class="btn secondary" id="btnRecolor">Recolor</button>
          <button class="btn secondary" id="btnClear">Bersihkan</button>
        </div>
        <div style="margin-top:8px"><span class="status" id="status">Auto-load <b>DTM.xyz</b> jika ada…</span></div>
        <div class="muted" style="margin-top:8px">Sistem koordinat diasumsikan <b>UTM 49S (EPSG:32749)</b> → otomatis ke WGS84.</div>
      </div>

      <div class="card">
        <h3>Titik</h3>
        <div class="row">
          <div>
            <label>Point Size</label>
            <input id="pointSize" type="number" value="6" min="1" step="1" />
          </div>
          <div>
            <label>Z Offset (m)</label>
            <input id="zOffset" type="number" value="0" step="0.1" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="switch">
            <input id="pointsOnTop" type="checkbox" checked />
            <span class="muted">Always on Top</span>
          </div>
          <div class="switch">
            <input id="colorizePoints" type="checkbox" checked />
            <span class="muted">Warna = Bin DTM</span>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>DTM</h3>
        <div class="row">
          <div>
            <label>Grid Step (deg)</label>
            <input id="gridStepDeg" type="number" value="0.0005" step="0.0001" />
          </div>
          <div>
            <label>Z Exaggeration</label>
            <input id="zExag" type="number" value="1.0" step="0.1" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label>Bins</label>
            <input id="bins" type="number" value="15" min="4" max="64" step="1" />
          </div>
          <div>
            <label>Palette</label>
            <select id="palette">
              <option value="bgyor" selected>Biru→Hijau→Kuning→Oranye→Merah</option>
              <option value="jet">Jet</option>
              <option value="viridis">Viridis</option>
            </select>
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="switch">
            <input id="autoZRange" type="checkbox" checked />
            <span class="muted">Range Z Auto</span>
          </div>
          <div>
            <label>Z Min, Z Max (manual)</label>
            <input id="zMinMax" type="text" placeholder="mis. 2.64, 11.19" />
          </div>
        </div>
        <div class="switch" style="margin-top:8px">
          <input id="underground" type="checkbox" />
          <span class="muted">Underground (terrain transparan)</span>
        </div>
      </div>
    </div>
  </aside>

  <!-- ========== MAP PANEL ========== -->
  <main id="map">
    <div id="cesiumContainer"></div>
    <!-- Legend mengambang (kanan bawah) -->
    <div id="legend">
      <h5>Elevation (m)</h5>
      <canvas id="legendCanvas" width="56" height="260"></canvas>
      <div id="legendTicks" class="muted"></div>
    </div>
    <div id="popup"></div>
  </main>
</div>

<script>
(async function(){
  Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJhNGQwNTBlZS1iOGVlLTQxZDgtODdiMC03YWQ1ZGUzYWFjZTQiLCJpZCI6MjUyMDkzLCJpYXQiOjE3NjA0MTgyNjB9.N9LrYm3UyvJs5Qgkm2P2DDbIReiWGp1MGOqz-fwfHTc";

  const viewer = new Cesium.Viewer('cesiumContainer', {
    terrainProvider: await Cesium.createWorldTerrainAsync(),
    baseLayerPicker: true, geocoder: false, homeButton: true,
    animation: false, timeline: false, sceneModePicker: true, navigationHelpButton: false
  });
  viewer.scene.globe.depthTestAgainstTerrain = false;

  // Hilangkan credit/watermark Cesium
  try { viewer.cesiumWidget.creditContainer.style.display = 'none'; } catch(e){}

  // Tambahkan OSM 3D Buildings
  try { viewer.scene.primitives.add(await Cesium.createOsmBuildingsAsync()); } catch(e){ console.warn(e); }

  // ====== CRS
  const UTM49S = "+proj=utm +zone=49 +south +datum=WGS84 +units=m +no_defs";
  const WGS84  = "+proj=longlat +datum=WGS84 +no_defs";

  // ====== Layers & state
  const pointLayer = new Cesium.PointPrimitiveCollection();
  viewer.scene.primitives.add(pointLayer);
  let dtmPrimitive = null;

  let lonlatz = [];   // {lon,lat,z} offset-applied
  let rawUTM  = [];   // {E,N,Z}
  let zStats  = null; // {min,max}

  // ====== UI refs
  const $ = id => document.getElementById(id);
  const statusEl=$("status"), fileInput=$("fileInput"), btnLoad=$("btnLoad"),
        btnBuildDTM=$("btnBuildDTM"), btnRecolor=$("btnRecolor"), btnClear=$("btnClear");
  const delimiterSel=$("delimiter"), zExagInp=$("zExag"), gridStepInp=$("gridStepDeg");
  const pointSizeInp=$("pointSize"), zOffsetInp=$("zOffset"),
        undergroundChk=$("underground"), pointsOnTop=$("pointsOnTop"),
        binsInp=$("bins"), autoZRange=$("autoZRange"), zMinMax=$("zMinMax"),
        paletteSel=$("palette"), colorizePoints=$("colorizePoints");
  const legendCanvas=$("legendCanvas"), legendTicks=$("legendTicks");
  const popupEl=$("popup");
  const setStatus = html => statusEl.innerHTML = html;

  // ===== Helpers
  function parseLine(line, mode){
    let parts;
    if (mode==="comma") parts=line.split(",");
    else if (mode==="space") parts=line.trim().split(/\s+/);
    else parts = line.includes(",") ? line.split(",") : line.trim().split(/\s+/);
    if (parts.length < 3) return null;
    return parts.slice(0,3).map(v=>parseFloat(v));
  }

  function parseUTM49S(text){
    const lines=text.split(/\r?\n/);
    const utm=[], wgs=[];
    const zOffset=Number(zOffsetInp.value)||0;
    let zMin=+Infinity, zMax=-Infinity;

    for (const raw of lines){
      const line=raw.trim(); if (!line) continue;
      if (!/[-+0-9.]/.test(line[0])) continue;
      const v=parseLine(line, delimiterSel.value); if (!v) continue;
      let [E,N,Z]=v; if (isNaN(E)||isNaN(N)||isNaN(Z)) continue;
      const [lon,lat]=proj4(UTM49S, WGS84, [E,N]);
      const zAdj=Z + zOffset;
      zMin=Math.min(zMin,zAdj); zMax=Math.max(zMax,zAdj);
      utm.push({E,N,Z}); wgs.push({lon,lat,z:zAdj});
    }
    return {utm,wgs,zMin,zMax};
  }

  function flyToBounds(data){
    if (!data.length) return;
    let minLon=+Infinity,minLat=+Infinity,maxLon=-Infinity,maxLat=-Infinity;
    for (const p of data){
      minLon=Math.min(minLon,p.lon); minLat=Math.min(minLat,p.lat);
      maxLon=Math.max(maxLon,p.lon); maxLat=Math.max(maxLat,p.lat);
    }
    const rect=Cesium.Rectangle.fromDegrees(minLon,minLat,maxLon,maxLat);
    viewer.camera.flyTo({destination:rect,duration:1.1});
  }

  // palettes
  function hex(h){const v=h.replace('#','');return [parseInt(v.slice(0,2),16),parseInt(v.slice(2,4),16),parseInt(v.slice(4,6),16)];}
  function lerp(a,b,t){return a+(b-a)*t;}
  function lerpC(c1,c2,t){return [Math.round(lerp(c1[0],c2[0],t)),Math.round(lerp(c1[1],c2[1],t)),Math.round(lerp(c1[2],c2[2],t))];}
  function makePalette(name, n){
    const arr=[];
    if (name==="viridis"){
      const stops=[[68,1,84],[59,82,139],[33,145,140],[94,201,98],[253,231,37]];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    } else if (name==="jet"){
      const stops=[[0,0,131],[0,60,170],[5,255,255],[255,255,0],[250,0,0],[128,0,0]];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    } else {
      const stops=[hex("#0000ff"),hex("#00ff00"),hex("#ffff00"),hex("#ff9900"),hex("#ff0000")];
      for(let i=0;i<n;i++){const t=i/(n-1), s=t*(stops.length-1), a=Math.floor(s), b=Math.min(stops.length-1,a+1); arr.push(lerpC(stops[a],stops[b],s-a));}
    }
    return arr;
  }

  function computeZRange(){
    if (autoZRange.checked || !zMinMax.value.trim()){
      return [zStats?.min ?? Math.min(...lonlatz.map(p=>p.z)),
              zStats?.max ?? Math.max(...lonlatz.map(p=>p.z))];
    }
    const parts=zMinMax.value.split(',').map(s=>parseFloat(s.trim()));
    if (parts.length>=2 && parts.every(v=>!isNaN(v))) return [parts[0],parts[1]];
    return [Math.min(...lonlatz.map(p=>p.z)), Math.max(...lonlatz.map(p=>p.z))];
  }

  // legend
  function drawLegend(colors, zmin, zmax, ticks=6){
    const canvas = legendCanvas;
    const ctx=canvas.getContext('2d');
    const w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    const n=colors.length;
    for(let i=0;i<n;i++){
      const c=colors[n-1-i];
      ctx.fillStyle=`rgb(${c[0]},${c[1]},${c[2]})`;
      const y=i*(h/n);
      ctx.fillRect(24,y,w-24,h/n+1);
    }
    ctx.fillStyle="#eaeef6"; ctx.font="11px system-ui";
    ctx.textAlign="right"; ctx.textBaseline="middle";
    for(let i=0;i<ticks;i++){
      const t=i/(ticks-1);
      const z=lerp(zmin,zmax,1-t);
      const y=lerp(0,h,t);
      ctx.fillRect(20,y,4,1);
      ctx.fillText(z.toFixed(1)+" m",18,y);
    }
    legendTicks.textContent = `Bins: ${n}  |  Range: ${zmin.toFixed(2)} – ${zmax.toFixed(2)} m`;
  }

  function colorIndexForZ(z, zmin, zmax, bins){
    if (zmax===zmin) return 0;
    let t=(z - zmin)/(zmax - zmin);
    t=Math.max(0,Math.min(1,t));
    return Math.min(bins-1, Math.floor(t*bins));
  }

  // DTM quantized (PerInstanceColorAppearance)
  function buildDTMQuantized(data, stepDeg, zExag, bins, palette, zmin, zmax){
    stepDeg = Math.max(1e-6, Number(stepDeg)||0.0005);
    zExag   = Number(zExag)||1.0;
    bins    = Math.max(4, Math.min(256, Math.floor(bins)||15));
    const colors = makePalette(palette, bins);

    // bounds
    let minLon=+Infinity,minLat=+Infinity,maxLon=-Infinity,maxLat=-Infinity;
    for(const d of data){minLon=Math.min(minLon,d.lon);minLat=Math.min(minLat,d.lat);maxLon=Math.max(maxLon,d.lon);maxLat=Math.max(maxLat,d.lat);}
    const nx=Math.max(2, Math.floor((maxLon-minLon)/stepDeg)+2);
    const ny=Math.max(2, Math.floor((maxLat-minLat)/stepDeg)+2);

    const sum=new Float64Array(nx*ny), cnt=new Uint32Array(nx*ny);
    const idx=(ix,iy)=>iy*nx+ix;
    for(const p of data){
      const ix=Math.min(nx-1,Math.max(0,Math.floor((p.lon-minLon)/stepDeg)));
      const iy=Math.min(ny-1,Math.max(0,Math.floor((p.lat-minLat)/stepDeg)));
      const k=idx(ix,iy); sum[k]+=p.z; cnt[k]+=1;
    }

    const positions=new Float64Array(nx*ny*3);
    const vcolors =new Uint8Array(nx*ny*4);
    let ptrP=0, ptrC=0;

    for(let iy=0;iy<ny;iy++){
      const lat=minLat+iy*stepDeg;
      for(let ix=0;ix<nx;ix++){
        const lon=minLon+ix*stepDeg;
        const k=idx(ix,iy);
        const zraw = cnt[k]?(sum[k]/cnt[k]):zmin;
        const z = zraw * zExag;
        const c3=Cesium.Cartesian3.fromDegrees(lon,lat,z);
        positions[ptrP++]=c3.x; positions[ptrP++]=c3.y; positions[ptrP++]=c3.z;

        const ci   = colorIndexForZ(zraw, zmin, zmax, bins);
        const col  = colors[ci];
        vcolors[ptrC++]=col[0]; vcolors[ptrC++]=col[1]; vcolors[ptrC++]=col[2]; vcolors[ptrC++]=220;
      }
    }

    const cellsX=nx-1, cellsY=ny-1;
    const indices=new Uint32Array(cellsX*cellsY*2*3);
    let ip=0;
    for(let iy=0;iy<cellsY;iy++){
      for(let ix=0;ix<cellsX;ix++){
        const a=iy*nx+ix, b=a+1, c=a+nx, d=c+1;
        indices[ip++]=a; indices[ip++]=c; indices[ip++]=b;
        indices[ip++]=b; indices[ip++]=c; indices[ip++]=d;
      }
    }
    return {positions, indices, vcolors, paletteColors: colors};
  }

  function renderDTM(grid){
    if (!grid) return;
    if (dtmPrimitive){ viewer.scene.primitives.remove(dtmPrimitive); dtmPrimitive=null; }

    const geometry = new Cesium.Geometry({
      attributes:{
        position:new Cesium.GeometryAttribute({
          componentDatatype:Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute:3,
          values:grid.positions
        }),
        color:new Cesium.GeometryAttribute({
          componentDatatype:Cesium.ComponentDatatype.UNSIGNED_BYTE,
          componentsPerAttribute:4,
          values:grid.vcolors,
          normalize:true
        })
      },
      indices:grid.indices,
      primitiveType:Cesium.PrimitiveType.TRIANGLES,
      boundingSphere:Cesium.BoundingSphere.fromVertices(grid.positions),
      vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
    });

    dtmPrimitive = new Cesium.Primitive({
      geometryInstances: new Cesium.GeometryInstance({geometry}),
      appearance: new Cesium.PerInstanceColorAppearance({translucent:true, closed:false}),
      asynchronous: true
    });

    viewer.scene.primitives.add(dtmPrimitive);
  }

  function colorForPoint(z, zmin, zmax, colors){
    const bins=colors.length;
    const idx = colorIndexForZ(z, zmin, zmax, bins);
    const c = colors[idx];
    return new Cesium.Color(c[0]/255,c[1]/255,c[2]/255,0.95);
  }

  function showPoints(colorsForBins){
    pointLayer.removeAll();
    const ps=Math.max(1, Number(pointSizeInp.value)||6);
    const [zmin,zmax]=computeZRange();

    for(let i=0;i<lonlatz.length;i++){
      const p=lonlatz[i], u=rawUTM[i];
      const col = (colorizePoints.checked && colorsForBins)
        ? colorForPoint(p.z, zmin, zmax, colorsForBins)
        : Cesium.Color.CYAN.withAlpha(0.95);
      const pt = pointLayer.add({
        position: Cesium.Cartesian3.fromDegrees(p.lon,p.lat,p.z),
        pixelSize: ps,
        color: col,
        outlineColor: Cesium.Color.WHITE.withAlpha(0.9),
        outlineWidth: 1,
        id:{type:"utm-point",index:i,lon:p.lon,lat:p.lat,z:p.z,E:u.E,N:u.N,Z:u.Z}
      });
      pt.disableDepthTestDistance = pointsOnTop.checked ? Number.POSITIVE_INFINITY : 0.0;
    }
    flyToBounds(lonlatz);
  }

  // Popup
  const handler=new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  handler.setInputAction((movement)=>{
    const picked=viewer.scene.pick(movement.position);
    const popup=popupEl;
    if (!picked || !picked.primitive || !picked.primitive.id){ popup.style.display="none"; return; }
    const d=picked.primitive.id;
    if (d.type!=="utm-point"){ popup.style.display="none"; return; }
    popup.innerHTML=`
      <h4>XYZ UTM 49S → WGS84</h4>
      <div class="rowp"><span>Easting</span><span>${d.E.toFixed(3)} m</span></div>
      <div class="rowp"><span>Northing</span><span>${d.N.toFixed(3)} m</span></div>
      <div class="rowp"><span>Z (asli)</span><span>${d.Z.toFixed(3)} m</span></div>
      <div class="rowp"><span>Lon</span><span>${d.lon.toFixed(6)}°</span></div>
      <div class="rowp"><span>Lat</span><span>${d.lat.toFixed(6)}°</span></div>
      <div class="rowp"><span>Z (offset)</span><span>${d.z.toFixed(3)} m</span></div>`;
    popup.style.left = movement.position.x + 12 + "px";
    popup.style.top  = movement.position.y + 12 + "px";
    popup.style.display="block";
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
  viewer.camera.moveStart.addEventListener(()=>{ popupEl.style.display="none"; });

  // Toggles
  function applyUnderground(on){
    const globe=viewer.scene.globe;
    globe.translucency.enabled=!!on;
    if (on) globe.translucency.frontFaceAlpha=0.5;
    viewer.scene.screenSpaceCameraController.enableCollisionDetection=!on;
  }
  document.getElementById('underground').addEventListener('change',()=>applyUnderground(undergroundChk.checked));
  document.getElementById('pointSize').addEventListener('change', ()=> showPoints(paletteCache));
  document.getElementById('colorizePoints').addEventListener('change', ()=> showPoints(paletteCache));
  document.getElementById('pointsOnTop').addEventListener('change', ()=> showPoints(paletteCache));

  // Load flow
  const status = msg => setStatus(msg);

  async function loadAndRenderText(text){
    status('Konversi UTM 49S → WGS84…');
    const {utm,wgs,zMin,zMax}=parseUTM49S(text);
    if (!wgs.length){ status('Gagal parsing. Cek delimiter & format.'); return; }
    rawUTM=utm; lonlatz=wgs; zStats={min:zMin,max:zMax};
    showPoints(null);
    status(`Titik: ${lonlatz.length.toLocaleString()} | Z[min,max]=[${zMin.toFixed(2)}, ${zMax.toFixed(2)}]`);
  }

  let paletteCache=null;

  function computeAndRenderDTM(){
    if (!lonlatz.length){ status('Tidak ada data. Load dulu.'); return; }
    const bins = Math.max(4, Math.min(256, parseInt(binsInp.value)||15));
    const [zmin,zmax] = computeZRange();
    const grid = buildDTMQuantized(lonlatz, gridStepInp.value, zExagInp.value, bins, paletteSel.value, zmin, zmax);
    renderDTM(grid);
    paletteCache = grid.paletteColors;
    drawLegend(paletteCache, zmin, zmax, 6);
    if (colorizePoints.checked) showPoints(paletteCache);
    status(`DTM siap ✔ | Bins=${bins} | Range=[${zmin.toFixed(2)}, ${zmax.toFixed(2)}] m`);
  }

  document.getElementById('btnLoad').addEventListener('click', async ()=>{
    const f=fileInput.files && fileInput.files[0];
    if (!f){ status('Pilih file XYZ/CSV dulu.'); return; }
    const t=await f.text(); await loadAndRenderText(t);
  });
  document.getElementById('btnBuildDTM').addEventListener('click', computeAndRenderDTM);
  document.getElementById('btnRecolor').addEventListener('click', computeAndRenderDTM);

  document.getElementById('btnClear').addEventListener('click', ()=>{
    pointLayer.removeAll();
    if (dtmPrimitive){ viewer.scene.primitives.remove(dtmPrimitive); dtmPrimitive=null; }
    lonlatz=[]; rawUTM=[]; zStats=null; fileInput.value=''; popupEl.style.display='none';
    legendTicks.textContent = ""; const ctx=legendCanvas.getContext('2d'); ctx.clearRect(0,0,legendCanvas.width,legendCanvas.height);
    status('Bersih. Siap upload baru.');
  });

  document.getElementById('zOffset').addEventListener('change', ()=>{
    if (!rawUTM.length) return;
    const zOff=Number(zOffsetInp.value)||0;
    lonlatz=lonlatz.map((p,i)=>({lon:p.lon,lat:p.lat,z:rawUTM[i].Z+zOff}));
    const zs=lonlatz.map(p=>p.z); zStats={min:Math.min(...zs), max:Math.max(...zs)};
    showPoints(paletteCache);
    if (dtmPrimitive) computeAndRenderDTM();
    status(`Z Offset: ${zOff} m`);
  });

  // Auto-load DTM.xyz
  try{
    const resp=await fetch('./DTM.xyz',{cache:'no-store'});
    if (resp.ok){
      const text=await resp.text();
      await loadAndRenderText(text);
      status('Auto-load DTM.xyz ✔ — klik "Buat DTM" untuk pewarnaan');
    }else{
      status('DTM.xyz tidak ditemukan. Silakan unggah file.');
    }
  }catch(e){ status('Gagal membaca DTM.xyz. Silakan unggah file.'); console.warn(e); }
})();
</script>
</body>
</html>
